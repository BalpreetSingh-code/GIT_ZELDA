# Dev Log - Zelda Assignment 4

## AI Involvement Category

**Assistant** - I used AI (Claude) to help with overall comprehension did not use it for coding what so ever.

---

## Approach & Design Decisions

### Hearts Implementation

- **Decision**: Create a Heart class extending GameObject with collision detection
- **Why**: Hearts needed to be game objects that players could interact with, similar to other pickups
- **Implementation**:
  - Hearts spawn with 30% probability when enemies die
  - Heal 2 health points (1 full heart)
  - Disappear on collision with player
  - Health capped at maximum to prevent overflow

### Pots Implementation

- **Decision**: Created multiple player states (lifting, carrying, throwing) and separate Pot/ThrownPot classes
- **Why**: Needed to manage complex state transitions and different behaviors for stationary vs. thrown pots
- **Implementation**:
  - PlayerPotLiftingState: Handles pickup animation
  - PlayerPotCarryingState: Pot follows player, disables sword
  - PlayerPotThrowingState: Launches pot as projectile
  - ThrownPot: Separate class for airborne pots with collision damage
  - Pots deal 1 damage to enemies on hit

## Challenges & Solutions

### Challenge 1: Understanding State Machine Pattern

- **Problem**: Initially confused about how player states transition between each other
- **What I tried**: Read through the documentation on state machines and existing player states
- **Solution**: Realized each state needs to handle its own transitions and pass control to the next state
- **What I learned**: State pattern keeps code organized by separating behavior into distinct classes

### Challenge 2: Heart Drop Probability

- **Problem**: Needed to implement random heart drops from enemies
- **Solution**: Used Math.random() < 0.3 in enemy death logic to create 30% drop rate
- **What I learned**: Simple probability checks can create interesting gameplay variety

### Challenge 3: Y-Sorting with Carried Pots

- **Problem**: Needed pots to render above player's head while maintaining proper y-sorting with other entities
- **Solution**: Used renderPriority to override default sorting when pot is being carried
- **What I learned**: Render priority can override y-sorting for special cases

### Challenge 4: Pot Collision Detection

- **Problem**: Thrown pots needed to collide with walls, enemies, and break after traveling certain distance
- **Solution**: Added collision checks in ThrownPot update method, tracking distance traveled
- **What I learned**: Projectiles need careful state management for multiple collision scenarios

## Testing & Verification

### Hearts Testing

- How I tested: Killed multiple enemies to verify 30% drop rate
- Edge cases checked:
  - Player at max health (hearts still appear but don't overheal)
  - Multiple hearts on screen
  - Hearts don't heal beyond maximum health
- Issues found: Initially forgot to cap health at maximum

### Pots Testing

- How I tested:
  - Lifted pots in all directions
  - Carried pots while walking
  - Threw pots at walls and enemies
  - Verified sword disabled while carrying
- Edge cases checked:
  - Throwing pot at room boundaries
  - Multiple pots in same room
  - Pot collision with different enemy types
  - Distance-based pot breaking
- Issues found: Pot positioning initially offset when carried
